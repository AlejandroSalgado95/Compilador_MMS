{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww11200\viewh13680\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \'bfcomo se hacen las llamadas a funciones como parte de una expresi\'f3n?\
\
Si son llamadas a funciones no void, significa que su valor de retorno ya esta programado para \
ser utilizado cu\'e1druplos mas adelante (el cual se encuentra indexado con el mismo nombre que\
la funci\'f3n llamada), sin embargo, llamar a una funci\'f3n hace que la funci\'f3n se realice y por lo tanto\
inicialice o asigne un valor a esa variable de retorno que ya esta programada para ser utilizada.\
Al llamar a una funci\'f3n, se realiza un cambio de contexto en cuanto se encuentra el cu\'e1druplo \'93era\'94, esto significa que se guarda la memoria temporal actual en un stack y se crea memoria temporal nueva para la funci\'f3n llamada, tambi\'e9n m\'e1s adelante como parte de  \
ese cambio de contexto (pero hecho por la acci\'f3n \'93gosub\'94) se guarda en un stack en que funci\'f3n estaba antes de haber hecho el cambio de contexto, y tambi\'e9n se guarda en otro stack en que iP (apuntador a cu\'e1druplo) estaba antes de hacer el cambio de contexto. Hecho el cambio de contexto, se procede con los siguientes \
cu\'e1druplos, que son la asignaci\'f3n a los par\'e1metros de una funci\'f3n, lo cual sucede de la siguiente manera: los par\'e1metros de una funci\'f3n ya se les fue asignada desde compilaci\'f3n una direcci\'f3n, y los cu\'e1druplos esperan que haya algo en esas direcciones cuando estos par\'e1metros vayan a ser utilizados en alg\'fan cu\'e1druplo mas adelante, por lo que lo \'fanico que hay que hacer es mover los valores que tenemos en los cu\'e1druplos con acci\'f3n \'93parameter\'94 a la direcci\'f3n virtual en donde se espera que guardemos los valores de los par\'e1metros de la funci\'f3n para que estos puedan ser utilizados en los cu\'e1druplos de mas adelante donde se opera con ellos, y es as\'ed como dejamos inicializados los par\'e1metros. Luego de inicializar los par\'e1metros de la funci\'f3n, lo siguiente que falta es ejecutar la funci\'f3n llamada al haya el \'93gosub\'94), lo cual ocurre simplemente cambiando el IP actual al IP  de inicio de la funci\'f3n (obviamente como se menciono antes, guardando en un stack el IP donde nos quedamos y el nombre de la funci\'f3n en la que est\'e1bamos, es en esta acci\'f3n donde ocurre es aparte del cambio de contexto). Finalmente, al realizar la funci\'f3n, en funciones no void nos topamos con una acci\'f3n \'93return\'94, la cual hace que se guarde en memoria global, en aquella direcci\'f3n indexada con el mismo nombre que la funci\'f3n activa (he aqu\'ed por que guardar en un stack las funciones que van quedando pendientes de resolver es util, pues nos permite recordar a quien deb\'edamos darle return), el valor que se encuentra almacenado en uno de los operando del cu\'e1druplo return y que esta presto para ser guardado  como variable global, representando as\'ed el valor de retorno de la funci\'f3n. De esta manera, dicha direcci\'f3n indexada con el nombre de la funci\'f3n queda asignada o inicializada, y por lo tanto, lista para ser utilizada por los siguientes cu\'e1druplos, como se ten\'eda programado hacer. Sin embargo, como se hizo para agregar esa variable global, retorno de la funci\'f3n llamada, a los cu\'e1druplos sin si quiera tener un valor? la respuesta es que en compilaci\'f3n, al encontrarse con el fin de la llamada, no solo se agrega el cu\'e1druplo \'93gosub\'94, sino que se agrega como operando a la lista de operandos a la variable esperada (\'f3sea, el valor de retorno de la funci\'f3n, la cual se llama igual que el nombre de la funci\'f3n llamada), y eso hace que el compilador siga corriendo y use ese operando agregado (el valor de retorno de la funci\'f3n llamada) en los cu\'e1druplos de otras operaciones\
\
\'bfcomo funciona la declaraci\'f3n de los arreglos?\
Declarar un arreglo es sencillo pues comienzas con el valor m\'e1ximo de indexamiento, que es una constante la cual puede ser le\'edda desde compilaci\'f3n; para hacer esto lo \'fanico que hay que hacer es: asignarle a la variable su direcci\'f3n base (al igual que se hace con el resto de las variables al ser declaradas, que se les asigna la ultima direcci\'f3n virtual disponible), pero a diferencia del resto, se hace un desplazamiento en la disponibilidad de memorias virtuales no en 1, sino en k, siendo k el tama\'f1o del arreglo (es decir, en vez de asumir que la siguiente direcci\'f3n virtual esta disponible, la siguiente direcci\'f3n virtual disponible estar\'e1 k direcciones m\'e1s adelante). esto quiere decir que al asignarle memoria a una arreglo, se le proporciona su direcci\'f3n base, y se dejan reservadas k direcciones para uso privado del arreglo\
\
\'bfcomo funciona el acceso a arreglos?\
Hacer esto es m\'e1s complicado si no se consta de una constate para acceder directamente a la direcci\'f3n del arreglo, pues si se trata de un indexamiento directo (una constante como indice), es f\'e1cil acceder a la direcci\'f3n del arreglo solicitada, pero si se trata de un indexamiento indirecto (el index es una expresi\'f3n), no queda m\'e1s que movernos a ejecuci\'f3n para poder resolver la expresi\'f3n y as\'ed conocer el valor de indexamiento. El proceso ocurre como sigue (para el indexamiento indirecto, porque el indexamiento directo es trivial y se puede resolver en compilaci\'f3n): como existe un conflicto entre que el compilador necesita seguir corriendo y operar con la direcci\'f3n del arreglo ya como un operando disponible para ser usado por los siguientes cu\'e1druplos, pero como no se puede disponer de tal operando completo pues no se puede conocer la direcci\'f3n verdadera del arreglo sino hasta ejecuci\'f3n, lo que se hace es mandar como operando a la lista de operandos un operando con la informaci\'f3n b\'e1sica del arreglo y una \'93una migaja de pan secreta\'94 (para acordarnos en ejecuci\'f3n que a ese operando, que es el arreglo al que se esta acezando, le falta su direcci\'f3n virtual verdadera), y como migaja de pan usaremos lo siguiente: antes de guardar el operador antes mencionado, tuvimos que haber forzado la inserci\'f3n de un cu\'e1druplo que realice la suma entre la direcci\'f3n base del arreglo y el resultado final de la expresi\'f3n, lo cual generara un operando resultante temporal (el cual tiene su propia y \'fanica direcci\'f3n virtual), y como es este operando en el cual se encontrar\'e1 lo que buscamos (el index real del arreglo), sera a este operando al que usemos como migaja de pan, agregando al operando incompleto del arreglo adem\'e1s de su direcci\'f3n base, una direcci\'f3n falsa donde guardemos la direcci\'f3n de aquel operando que tiene guardado su direcci\'f3n verdadera. suena complicado, pero el orden de los eventos es realmente el siguiente: en compilaci\'f3n, me encuentro con que el index es una expresi\'f3n, por lo que hago un cu\'e1druplo que sume la direcci\'f3n base con la expresi\'f3n, lo cual guarda en el cu\'e1druplo un temporal como resultado, y ademas lo retorna; en este temporal se encuentra la direcci\'f3n verdadera del arreglo, por lo que al operando del arreglo le dejo guardado (en su atributo fakeAddress) QUI\'c9N tiene guardada el valor de su direcci\'f3n de indexamiento real, es decir, le agrego al operando del arreglo la direcci\'f3n en la cual esta su verdadera direcci\'f3n de indexamiento, y esa direcci\'f3n es la de la temporal resultante de sumar la direcci\'f3n base del arreglo con el resultado de la expresi\'f3n, y finalmente inserto un cu\'e1druplo \'93arrayindex\'94 cuya misi\'f3n en ejecuci\'f3n es buscar aquel cu\'e1druplo donde se encuentra el operando del arreglo al que le deje la migaja de pan, para asignarle a ese operando de arreglo su address real, para que as\'ed las operaciones con ese arreglo puedan hacerse correctamente. Dicho esto, lo que hace en ejecuci\'f3n la acci\'f3n arrayindex es, recibir al operando en donde se encuentra el el valor real de indexamiento del arreglo, extraer dicho valor, y buscar en los cu\'e1druplos de m\'e1s adelante aquel operando donde deje la migaja de pan, pues es a ese al cual le tengo que cambiar su address por la address verdadera la cual es el valor mencionado extra\'eddo (el valor de indexamiento real) y que permitir\'e1 acceder correctamente a la casilla solicitada del arreglo. Esto es posible gracias a que es SOLO un operando al cual marque con una migaja de pan ESPECIFICA, independientemente de que haya mas operando con migajas de pan guardadas (mas arreglos pendientes de resolver en ejecuci\'f3n), en el momento de realizar una acci\'f3n \'93arrayindex\'94 es SOLO UN operando el que tiene la migaja de pan que estoy buscando; esto es, solo un operando tiene en su fakeaddress el mismo valor que el address del operando de indexamiento indirecto que estoy recibiendo en la acci\'f3n \'93arrayindex\'94. Por ejemplo, digamos en "arrayindex" recibi el operando A, y sabemos que la direccion de A es 1515, entonces debo buscar AQUEL UNICO operando cuya fakeaddress sea 1515, y es a ese operando al que le voy a asignar (no en su fakeaddress, sino en su address real) el valor contenido en A, el cual es la direcci\'f3n real del operando que tiene la migaja de pan.}